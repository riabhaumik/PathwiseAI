{
  "challenging_problems": {
    "title": "Challenging Coding & Math Problems",
    "description": "A curated collection of 15+ challenging problems to test your problem-solving skills",
    "problems": [
      {
        "id": "1",
        "title": "Dynamic Programming - Longest Palindromic Subsequence",
        "description": "Find the length of the longest palindromic subsequence in a string. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.",
        "difficulty": "Hard",
        "category": "Dynamic Programming",
        "example": "Input: 'bbbab', Output: 4 (bbbb)",
        "hint": "Think about the relationship between LPS and LCS with the reversed string",
        "solution_approach": "Use dynamic programming with a 2D array. LPS[i][j] = 2 + LPS[i+1][j-1] if s[i] == s[j], else max(LPS[i+1][j], LPS[i][j-1])",
                "time_complexity": "O(n²)",
        "space_complexity": "O(n²)",
        "related_topics": ["Dynamic Programming", "String Manipulation", "Longest Common Subsequence"]
      },
      {
        "id": "2",
        "title": "Graph Theory - Minimum Spanning Tree with Kruskal's",
        "description": "Implement Kruskal's algorithm to find the minimum spanning tree of a weighted, undirected graph. Handle edge cases like disconnected graphs and negative weights.",
        "difficulty": "Medium",
        "category": "Graph Theory",
        "example": "Graph with edges: (0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4)",
        "hint": "Sort edges by weight and use Union-Find to detect cycles",
        "solution_approach": "Sort edges by weight, use Union-Find data structure to detect cycles, add edges that don't form cycles",
        "time_complexity": "O(E log E) where E is number of edges",
        "space_complexity": "O(V + E)",
        "related_topics": ["Graph Theory", "Union-Find", "Sorting", "Minimum Spanning Tree"]
      },
      {
        "id": "3",
        "title": "Advanced Math - Matrix Chain Multiplication",
        "description": "Given a sequence of matrices, find the most efficient way to multiply them. The problem is to determine the order of matrix multiplications that minimizes the total number of scalar multiplications.",
        "difficulty": "Hard",
        "category": "Dynamic Programming",
        "example": "Matrices: A(10×30), B(30×5), C(5×60). Optimal: (AB)C = 10×30×5 + 10×5×60 = 1500 + 3000 = 4500",
        "hint": "Use dynamic programming to try all possible split points",
        "solution_approach": "DP[i][j] = min cost to multiply matrices i through j. Try all split points k: DP[i][j] = min(DP[i][k] + DP[k+1][j] + cost[i][k][j])",
        "time_complexity": "O(n³)",
        "space_complexity": "O(n²)",
        "related_topics": ["Dynamic Programming", "Matrix Operations", "Optimization"]
      },
      {
        "id": "4",
        "title": "Algorithm Design - Sliding Window Maximum",
        "description": "Given an array and a window size k, find the maximum element in each sliding window of size k. Optimize for both time and space complexity.",
        "difficulty": "Hard",
        "category": "Data Structures",
        "example": "Array: [1,3,-1,-3,5,3,6,7], k=3. Output: [3,3,5,5,6,7]",
        "hint": "Use a monotonic queue (deque) to maintain the maximum element",
        "solution_approach": "Use a deque to maintain indices of elements in decreasing order. Remove elements outside window and smaller than current element",
        "time_complexity": "O(n)",
        "space_complexity": "O(k)",
        "related_topics": ["Sliding Window", "Monotonic Queue", "Deque", "Optimization"]
      },
      {
        "id": "5",
        "title": "Number Theory - Prime Factorization with Pollard's Rho",
        "description": "Implement Pollard's Rho algorithm for integer factorization. This is a probabilistic algorithm that can factor large integers efficiently.",
        "difficulty": "Hard",
        "category": "Number Theory",
        "example": "Factor 8051 = 83 × 97",
        "hint": "Use Floyd's cycle-finding algorithm with a polynomial function",
        "solution_approach": "Use f(x) = x² + c mod n, detect cycles with Floyd's algorithm, use GCD to find factors",
        "time_complexity": "O(n^(1/4))",
        "space_complexity": "O(1)",
        "related_topics": ["Number Theory", "Prime Factorization", "Pollard's Rho", "Cycle Detection"]
      },
      {
        "id": "6",
        "title": "Data Structures - Persistent Segment Tree",
        "description": "Implement a persistent segment tree that can handle range queries and point updates while maintaining all previous versions of the tree.",
        "difficulty": "Hard",
        "category": "Data Structures",
        "example": "Support range sum queries and point updates with version history",
        "hint": "Create new nodes only when updating, share unchanged subtrees",
        "solution_approach": "Create new nodes for modified paths, share unchanged subtrees, maintain version pointers",
        "time_complexity": "O(log n) per operation",
        "space_complexity": "O(n log n) total",
        "related_topics": ["Segment Trees", "Persistence", "Range Queries", "Tree Data Structures"]
      },
      {
        "id": "7",
        "title": "Optimization - Traveling Salesman Problem with Branch and Bound",
        "description": "Solve the Traveling Salesman Problem using Branch and Bound with a lower bound heuristic. Implement pruning strategies to improve efficiency.",
        "difficulty": "Hard",
        "category": "Optimization",
        "example": "Find shortest tour visiting all cities exactly once",
        "hint": "Use minimum spanning tree as lower bound and implement strong pruning",
        "solution_approach": "Use MST cost as lower bound, implement branch and bound with pruning, use best-first search",
        "time_complexity": "O(n!) worst case, much better with pruning",
        "space_complexity": "O(n²)",
        "related_topics": ["Optimization", "Branch and Bound", "Traveling Salesman", "Graph Theory"]
      },
      {
        "id": "8",
        "title": "Advanced Algorithms - Suffix Automaton",
        "description": "Implement a suffix automaton for efficient string processing. Support operations like finding all occurrences of a pattern and counting distinct substrings.",
                "difficulty": "Hard",
        "category": "String Algorithms",
        "example": "Build automaton for 'abab' and find all occurrences of 'ab'",
        "hint": "Use online construction with clone nodes for efficient building",
        "solution_approach": "Build incrementally, add new states for new characters, clone states when needed",
        "time_complexity": "O(n) construction, O(m) pattern matching",
        "space_complexity": "O(n)",
        "related_topics": ["String Algorithms", "Automata Theory", "Pattern Matching", "Suffix Structures"]
      },
      {
        "id": "9",
        "title": "Computational Geometry - Convex Hull with Graham Scan",
        "description": "Implement Graham's scan algorithm to find the convex hull of a set of points. Handle edge cases like collinear points and duplicate coordinates.",
                "difficulty": "Medium",
        "category": "Computational Geometry",
        "example": "Find convex hull of points: (0,3), (1,1), (2,2), (4,4), (0,0), (1,2), (3,1), (3,3)",
        "hint": "Sort by polar angle from bottommost point, use cross product for orientation",
        "solution_approach": "Find bottommost point, sort by polar angle, use stack with cross product for orientation",
        "time_complexity": "O(n log n)",
        "space_complexity": "O(n)",
        "related_topics": ["Computational Geometry", "Convex Hull", "Graham Scan", "Sorting"]
      },
      {
        "id": "10",
        "title": "Machine Learning Math - Gradient Descent with Momentum",
        "description": "Implement gradient descent with momentum for optimizing a multivariate function. Include adaptive learning rates and convergence criteria.",
                "difficulty": "Medium",
        "category": "Optimization",
        "example": "Minimize f(x,y) = x² + y² + 2x + 3y + 5",
        "hint": "Use exponential moving average for momentum and implement backtracking line search",
        "solution_approach": "Update velocity with momentum, apply velocity to parameters, use adaptive learning rate",
        "time_complexity": "O(iterations × dimensions)",
        "space_complexity": "O(dimensions)",
        "related_topics": ["Optimization", "Gradient Descent", "Machine Learning", "Numerical Methods"]
      },
      {
        "id": "11",
        "title": "Cryptography - RSA Implementation",
        "description": "Implement RSA encryption and decryption from scratch. Include key generation, encryption, decryption, and padding schemes.",
                "difficulty": "Hard",
        "category": "Cryptography",
        "example": "Generate keys, encrypt 'HELLO', decrypt to verify",
        "hint": "Use Fermat's little theorem and Chinese remainder theorem for efficiency",
        "solution_approach": "Generate primes p,q, compute n=pq, choose e coprime to φ(n), compute d as e⁻¹ mod φ(n)",
        "time_complexity": "O(log³ n) for encryption/decryption",
        "space_complexity": "O(log n)",
        "related_topics": ["Cryptography", "Number Theory", "RSA", "Public Key Cryptography"]
      },
      {
        "id": "12",
        "title": "Parallel Algorithms - Parallel Merge Sort",
        "description": "Implement a parallel version of merge sort using divide-and-conquer. Handle load balancing and minimize communication overhead.",
                "difficulty": "Hard",
        "category": "Parallel Computing",
        "example": "Sort array of 1M elements using 4 threads",
        "hint": "Use recursive division, merge in parallel, minimize data movement",
        "solution_approach": "Divide array among threads, sort locally, merge in parallel using divide-and-conquer",
        "time_complexity": "O(n log n / p + p log p) where p is number of threads",
        "space_complexity": "O(n)",
        "related_topics": ["Parallel Computing", "Merge Sort", "Divide and Conquer", "Load Balancing"]
      },
      {
        "id": "13",
        "title": "Advanced Data Structures - B-Tree Implementation",
        "description": "Implement a B-tree data structure with insert, delete, and search operations. Handle node splitting and merging efficiently.",
        "difficulty": "Hard",
        "category": "Data Structures",
        "example": "Build B-tree of order 3, insert keys: 1,3,7,10,11,13,14,15,18,16,19,24,25,26,21,4,5,20,22,2,17,12,6",
        "hint": "Maintain balance by splitting full nodes and merging underflow nodes",
        "solution_approach": "Insert at leaf, split full nodes, delete with borrowing/merging, maintain balance",
        "time_complexity": "O(log n) for all operations",
        "space_complexity": "O(n)",
        "related_topics": ["B-Trees", "Balanced Trees", "Database Indexing", "File Systems"]
      },
      {
        "id": "14",
        "title": "Network Algorithms - Maximum Flow with Ford-Fulkerson",
        "description": "Implement Ford-Fulkerson algorithm to find maximum flow in a network. Use efficient augmenting path algorithms and handle residual graphs.",
        "difficulty": "Hard",
        "category": "Graph Theory",
        "example": "Find max flow from source to sink in network with capacity constraints",
        "hint": "Use BFS or DFS to find augmenting paths, update residual capacities",
        "solution_approach": "Find augmenting paths, compute bottleneck capacity, update residual graph, repeat until no more paths",
        "time_complexity": "O(VE²) with BFS, O(VE) with Dinic's algorithm",
        "space_complexity": "O(V²)",
        "related_topics": ["Network Flow", "Ford-Fulkerson", "Residual Graphs", "Graph Theory"]
      },
      {
        "id": "15",
        "title": "Quantum Computing - Grover's Algorithm Simulation",
        "description": "Simulate Grover's quantum search algorithm classically. Implement quantum gates, superposition, and measurement operations.",
                "difficulty": "Hard",
        "category": "Quantum Computing",
        "example": "Find marked item in unsorted database of size N using O(√N) queries",
        "hint": "Use Hadamard gates for superposition, oracle for marking, diffusion for amplitude amplification",
        "solution_approach": "Apply Hadamard to create superposition, apply oracle to mark solution, apply diffusion to amplify, measure",
        "time_complexity": "O(√N) quantum queries",
        "space_complexity": "O(log N) qubits",
        "related_topics": ["Quantum Computing", "Grover's Algorithm", "Quantum Gates", "Amplitude Amplification"]
      }
    ],
    "categories": {
      "Dynamic Programming": "Problems involving optimal substructure and overlapping subproblems",
      "Graph Theory": "Problems involving graphs, trees, and network structures",
      "Data Structures": "Advanced data structure implementations and optimizations",
      "Number Theory": "Mathematical problems involving integers, primes, and divisibility",
      "String Algorithms": "Efficient string processing and pattern matching",
      "Computational Geometry": "Geometric algorithms and spatial problems",
      "Optimization": "Finding optimal solutions to complex problems",
      "Cryptography": "Security algorithms and cryptographic protocols",
      "Parallel Computing": "Algorithms designed for concurrent execution",
      "Quantum Computing": "Quantum algorithms and quantum information processing"
    },
    "difficulty_levels": {
      "Easy": "Basic concepts, straightforward implementation",
      "Medium": "Requires algorithmic thinking and optimization",
      "Hard": "Advanced algorithms, complex data structures, mathematical insight"
    }
  }
} 